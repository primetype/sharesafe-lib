-- |
-- Module      : Prime.Servant.Models
-- License     : BSD-style
-- Maintainer  : Nicolas Di Prima <nicolas@primetype.co.uk>
-- Stability   : stable
-- Portability : Good
--
{-# LANGUAGE DeriveGeneric              #-}
{-# LANGUAGE EmptyDataDecls             #-}
{-# LANGUAGE FlexibleContexts           #-}
{-# LANGUAGE FlexibleInstances          #-}
{-# LANGUAGE GADTs                      #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE MultiParamTypeClasses      #-}
{-# LANGUAGE OverloadedStrings          #-}
{-# LANGUAGE QuasiQuotes                #-}
{-# LANGUAGE RecordWildCards            #-}
{-# LANGUAGE TemplateHaskell            #-}
{-# LANGUAGE TypeFamilies               #-}

module Prime.Servant.Models where

import Foundation

import Control.Monad.Reader

import Database.Persist.Sql
import Database.Persist.TH  (mkMigrate, mkPersist, persistLowerCase, share, sqlSettings)
import Servant.Server.Experimental.Auth.Cookie

import Prime.Common.Time
import Prime.Servant.Monad
import Prime.Secret ( PublicKey, PrivateKey
                    , Ciphered
                    , PasswordProtected, Password
                    , Commitment, Share
                    , Salt
                    , VerifyKey
                    )

share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persistLowerCase|
-- ------------------------------------------------------------------------- --
--                            User                                           --
-- ------------------------------------------------------------------------- --

-- | a given user
--
-- users are uniquely represented with their email address
--
User json
    email     LString
    name      LString
    created   Time
    UniqueUser email
    deriving Eq Show

-- | used to identify a user
--
-- user will generate a SigningKey with its password and the salt
-- the verify key will be to check the SigningKey is valid.
--
-- The user will sign some random bytes and will use it to generate a signature
-- we will check this signature to validate if the user is the one it pretends
-- to be.
--
UserIdentification json
    user      UserId
    verifyKey VerifyKey
    salt      (PasswordProtected Salt)
    UniqueUserIdentification user

-- User Password Recovery -----------------------------------------------------

-- | The Password has been ciphered with a PVSS shared secret.
--
-- The UserPassword behave exactly like a shared secret.
--
UserPassword json
    user                   UserId
    password               (Ciphered Password)
        -- ^ user must retrieve the DecryptedShare to get the secret
        -- to decrypt this password.
    recovering_commitments [Commitment]
        -- ^ the threshold to retrive the password
        --
        -- This is the minimal number of secret question one must respond
        -- to retrieve the secret. The secret being generated by the user
        -- it their reponsability to a good enough threshold.
    UniqueUserPassword user

-- | The hint, the secret question, with the password protected private key
-- The password being the response to the hint.
--
UserPasswordShares json
    password UserPasswordId
    hint     LString
        -- ^ the hint to unlock the private key
    secret   (PasswordProtected PrivateKey)
        -- ^ the password protected private key to unlock the share
    share    Share
        -- ^ the share to retrieve the PVSS for the user password

-- ------------------------------------------------------------------------- --
--                            Secret Sharing                                 --
-- ------------------------------------------------------------------------- --

-- | the user's public keys for secret sharing
--
UserKeyPair json
    user    UserId
    comment LString Maybe
    created Time
    public  PublicKey
    private (PasswordProtected PrivateKey)
    UniqueUserKey user public

-- | a secret generated by one user
DBSecret json
    comment     LString Maybe
    commitments [Commitment]
    created     Time

-- | a secret generated
DBSecretUser json
    secret DBSecretId
    user   UserId
    share  Share
    UniqueDBSecretUser secret user
|]

instance Ord User where
    compare u1 u2 = compare (userEmail u1) (userEmail u2)

type instance AuthCookieData = Int64

doMigrations :: SqlPersistT IO ()
doMigrations = runMigration migrateAll

runDB :: (MonadReader Config m, MonadIO m) => SqlPersistT IO b -> m b
runDB query = do
    pool <- asks getPool
    liftIO $ runSqlPool query pool
